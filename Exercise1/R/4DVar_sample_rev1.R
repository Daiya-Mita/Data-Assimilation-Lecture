#################################
#  Sample Program of 4DVar      #
#                               #
#  System Model: dx/dt = -x^2   #
#################################

Nt <- 520      # number of time points
dt <- 0.01     # time interval of one step
t  <- dt * c( 0:(Nt-1) )     # time
t_obs <- seq( 50, Nt, 50 )   # times at which observational data are obtained
x0_T  <- 2                   # true initial condition

# forward simulation
simulation <- function( x0 ) {
  x <- rep( 0, length=Nt )
  x[1] <- x0

  for ( k in 2:Nt ) {
    x[k] <- x[k-1] - x[k-1] * x[k-1] * dt
  }

  return(x)
}

x_T <- simulation(x0_T)  # True simulation

# observational data generated by the true solution
y <- x_T                        # noise-free
#y <- x_T + rnorm( Nt, sd=0.05 )  # noise added

# cost function
J <- function( x0, out_lmd ) {   # out_lmd is dummy
  x <- simulation(x0)

  res <- 0
  for ( k in 1:length(t_obs) ) {
    res <- res + 0.5 * ( x[t_obs[k]] - y[t_obs[k]] ) * ( x[t_obs[k]] - y[t_obs[k]] )
  }

  return(res)
}

# gradient of cost function computed by 4DVar
lmd <- rep( 0, length=Nt )   # adjoint variable

gradJ <- function( x0, out_lmd ) {
  x <- simulation(x0)

  for ( k in (Nt-1):1 ) {
    if ( any( t_obs==k ) ) {
      lmd[k] <- lmd[k+1] + 2 * x[k] * lmd[k+1] * dt + ( x[k] - y[k] ) * dt
    } else {
      lmd[k] <- lmd[k+1] + 2 * x[k] * lmd[k+1] * dt
    }
  }

  if ( out_lmd ) { lmd <<- lmd }

  return( lmd[1] )
}

# optimize the initial condition based on a gradient method
x0_init <- 4   # initial guess for initial condition
x_init <- simulation( x0_init )
dJ <- gradJ( x0_init, out_lmd=T )
lmd_init <- lmd
 
opt <- optim( c(x0_init), fn=J, gr=gradJ, out_lmd=F, method="CG", control=list( maxit=1000 ) )
x0_opt <- opt$par
x_opt  <- simulation( x0_opt )


# Figures
# time series
plot( t[t_obs], y[t_obs], xlim=c(t[1],t[Nt]), ylim=c(0,x0_init), xlab="t", ylab="x" )
par( new=T )
plot( t, x_T, type="l", col="black", xlim=c(t[1],t[Nt]), ylim=c(0,x0_init), xlab="", ylab="" )
par( new=T )
plot( t, x_init, type="l", col="blue", xlim=c(t[1],t[Nt]), ylim=c(0,x0_init), xlab="", ylab="" )
par( new=T )
plot( t, x_opt, type="l", col="red", xlim=c(t[1],t[Nt]), ylim=c(0,x0_init), xlab="", ylab="" )

# adjoint variable
dev.new()
plot( t, lmd_init, type="l", xlim=c(t[1],t[Nt]), xlab="t", ylab="lambda" )


